<style>

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: .5;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: .5px;
  stroke-opacity: .5;
}

.line {
  fill: none;
  stroke: #f00;
  stroke-width: 2px;
  stroke-opacity: 1.0;
}

.roi {
  fill: #08f;
  fill-opacity: 0.5;
  stroke: black;
  stroke-width: 0.5px;
}

</style>

<script type="text/javascript">
var domains = [
  { name: 'World', lat: [90, -90],  lon: [0, 360] },
  { name: 'Northern Hemisphere', lat: [90, 0] },
  { name: 'Southern Hemisphere', lat: [0, -90] },
  { name: 'Tropics', lat: [23.4, -23.4] },
  { name: 'Arctic Zone', lat: [90, 66.6] },
  { name: 'Antarctic Zone', lat: [-66.6, -90] },
];

var regrid = [
  'None', 'Gaussian', 'Uniform'
];

Number.prototype.map = function(in_min, in_max, out_min, out_max) {
  return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

function load_domains(dispatcher) {
  d3.select('#domains')
      .on('change', function() {
        var sel = domains[this.selectedIndex];

        if (sel.hasOwnProperty('lat')) {
          d3.select('#lat-start')
              .property('value', sel.lat[0]);

          d3.select('#lat-stop')
              .property('value', sel.lat[1]);
        }

        if (sel.hasOwnProperty('lon')) {
          d3.select('#lon-start')
              .property('value', sel.lon[0]);

          d3.select('#lon-stop')
              .property('value', sel.lon[1]);
        }

        dispatcher.call('updateRoi');
      })
      .selectAll('option')
      .data(domains)
    .enter().append('option')
      .text(function(d) { return d.name; });
}

function add_input(container, label, id, value, type) {
  d3.select(container)
      .append('label')
      .attr('for', id)
      .text(label);

  d3.select(container)
      .append('input')
      .attr('id', id)
      .attr('value', value)
      .attr('type', type);
}

function clear_regrid() {
  d3.select('#regridOptions')
      .selectAll('*')
      .remove();
}

function load_regrid() {
  d3.select('#regrid')
      .on('change', function() {
        var sel = regrid[this.selectedIndex];

        clear_regrid();

        if (sel.toLowerCase() === 'gaussian') {
          add_input('#regridOptions', 'Lats', 'gaussian', 32, 'number');
        } else if (sel.toLowerCase() === 'uniform') {
          add_input('#regridOptions', 'Lats', 'uniform-lat', 1, 'number');

          add_input('#regridOptions', 'Lons', 'uniform-lon', 1, 'number');
        }
      })
      .selectAll('option')
      .data(regrid)
    .enter().append('option')
      .text(function(d) { return d; });
}

function input(id) {
  return d3.select(id);
}

function cartesian(projection, id) {
  var lon = +input('#lon-' + id).attr('value');
  var lat = +input('#lat-' + id).attr('value');

  lon = lon.map(0, 360, -180, 180);

  return projection([lon, lat]);
}

$(document).ready(function() {
  var dispatcher = d3.dispatch('updateRoi');

  load_domains(dispatcher);

  load_regrid();

  var width = 960,
    height = 500,
    data = { };

  var f = d3.format('.5r');

  var color = d3.scaleOrdinal(d3.schemeCategory20);

  var projection = d3.geoEquirectangular();

  var path = d3.geoPath(projection);

  var graticule = d3.geoGraticule();

  var svg = d3.select('svg')
      .attr('width', width)
      .attr('height', height)
      .style('border-style', 'solid')
      .style('border-width', '0.5px');

  svg.append('path')
      .datum(graticule)
      .attr('class', 'graticule')
      .attr('d', path);

  data.start = cartesian(projection, 'start');

  data.stop = cartesian(projection, 'stop');

  var roi = svg.append('rect')
      .attr('x', data.start[0])
      .attr('y', data.start[1])
      .attr('width', data.stop[0] - data.start[0])
      .attr('height', data.stop[1] - data.start[1])
      .attr('class', 'roi');

  dispatcher.on('updateRoi', function() {
    var lon_start = +input('#lon-start').property('value');

    var lon_stop = +input('#lon-stop').property('value');

    var lat_start = +input('#lat-start').property('value');

    var lat_stop = +input('#lat-stop').property('value');

    lon_start = lon_start.map(0, 360, -180, 180);

    lon_stop = lon_stop.map(0, 360, -180, 180);

    data.start = projection([lon_start, lat_start]);

    data.stop = projection([lon_stop, lat_stop]);

    roi.attr('x', data.start[0])
        .attr('y', data.start[1])
        .attr('width', data.stop[0] - data.start[0])
        .attr('height', data.stop[1] - data.start[1]);

    d3.select('#domain_modified')
        .attr('value', true);
  });

  function onChange(id, prop, index, map, origin, shape) {
    d3.select(id)
        .on('change', function() {
          var old = data[prop][index];

          var value = (+this.value);

          if (map) {
            value = value.map(0, 360, -180, 180);
          }

          if (index == 0) {
            a = [value, 0];
          } else {
            a = [0, value];
          }

          data[prop][index] = projection(a)[index];

          var diff = data[prop][index] - old;

          roi.attr(origin, +roi.attr(origin) + diff);

          if (shape != undefined) {
            roi.attr(shape, +roi.attr(shape) - diff);
          }

          d3.select('#domain_modified')
              .attr('value', true);
        });
  }

  onChange('#lon-start', 'start', 0, true, 'x', 'width');

  onChange('#lat-start', 'start', 1, false, 'y', 'height');

  onChange('#lon-stop', 'stop', 0, true, 'width');

  onChange('#lat-stop', 'stop', 1, false, 'height');

  var tooltip = svg.append('text')
      .attr('x', 10)
      .attr('y', 20)
      .style('fill', 'black'); 

  svg.on('mousemove', function() {
    var coord = d3.mouse(this);

    var geoCoord = projection.invert(coord);

    tooltip.html(f(geoCoord[0]) + ' &deg;' + ' ' + f(geoCoord[1]) + ' &deg;');    
  });

  d3.json(window.location.origin + '/static/js/world.json', function(error, world) {
    if (error) throw error;

    var countries = topojson.feature(world, world.objects.countries).features,
      neighbors = topojson.neighbors(world.objects.countries.geometries);

    svg.selectAll('.country')
        .data(countries)
      .enter().insert('path', '.graticule')
        .attr('class', 'country')
        .attr('d', path)
        .style('fill', function(d, i) { return color(d.color = d3.max(neighbors[i], function(n) { return countries[n].color; }) + 1 | 0); });

    var boundaries = topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; });

    svg.insert('path', '.graticule')
        .datum(boundaries)
        .attr('class', 'boundary')
        .attr('d', path);
  });
});

</script>
