<style>

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: 1.0;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: .5px;
  stroke-opacity: .5;
}

.line {
  fill: none;
  stroke: #f00;
  stroke-width: 2px;
  stroke-opacity: 1.0;
}

.roi {
  fill: #08f;
  fill-opacity: 0.5;
  stroke: black;
  stroke-width: 0.5px;
}

td#dimension > input[type="number"] {
  width: 95%;
}

td#dimension > input[type="datetime"] {
  width: 95%;
}

</style>

<script type="text/javascript">

Number.prototype.map = function(in_min, in_max, out_min, out_max) {
  return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

wps = {
  resize: false,
  move: false,
  resizeDir: [false, false, false, false],
  data: {},
  DOMAINS: [
    { name: 'World', lat: [90, -90],  lon: [0, 360] },
    { name: 'Northern Hemisphere', lat: [90, 0] },
    { name: 'Southern Hemisphere', lat: [0, -90] },
    { name: 'Tropics', lat: [23.4, -23.4] },
    { name: 'Arctic Zone', lat: [90, 66.6] },
    { name: 'Antarctic Zone', lat: [-66.6, -90] },
  ],
  REGRID: [
    'None', 'Gaussian', 'Uniform'
  ],
};

wps.geoCoord = function(postFix) {
  return [
    (+d3.select('#lon-' + postFix).property('value')).map(0, 360, -180, 180),
    +d3.select('#lat-' + postFix).property('value'),
    ];
}

wps.loadDomains = function(dispatch) {
  d3.select('#domains')
      .on('change', function() {
        var domain = wps.DOMAINS[this.selectedIndex];

        if (domain.hasOwnProperty('lon')) {
          d3.select('#lon-start').attr('value', domain.lon[0]);

          d3.select('#lon-stop').attr('value', domain.lon[1]);
        }

        if (domain.hasOwnProperty('lat')) {
          d3.select('#lat-start').attr('value', domain.lat[0]);

          d3.select('#lat-stop').attr('value', domain.lat[1]);
        }

        wps.data.start = wps.projection(wps.geoCoord('start'));

        wps.data.stop = wps.projection(wps.geoCoord('stop'));

        dispatch.call('updateROI');
      })
      .selectAll('option')
      .data(wps.DOMAINS)
    .enter().append('option')
      .text(function(d) { return d.name; });

  d3.select('#add-dimension')
        .on('click', function() {
          var uuid = Date.now();

          var new_dim = d3.select('#domain')
                .select('tbody')
                .insert('tr', '#time')
                .attr('id', 'dim-' + uuid);

          var dims = d3.select('#dimensions')
                .property('value');

          dims = dims.split('|').filter(function(i) { return i !== ''; });

          dims.push(uuid.toString());

          d3.select('#dimensions')
                .attr('value', dims.join('|'))

          new_dim.html(`
              <td>
                <input name="dim-` + uuid + `-name" type="text" placeholder="Name" />
                <input type="button" value="Remove" onclick="removeDimension('dim-` + uuid + `'); return false;" />
              </td>
              <td id="dimension">
                <label for="start">Start</label>
                <input name="dim-` + uuid + `-start" type="number" />
                <label for="stop">Stop</label>
                <input name="dim-` + uuid + `-stop" type="number" />
                <label for="step">Step</label>
                <input name="dim-` + uuid + `-step" type="number" value="1" />
              </td>
              `);
        });
}

wps.removeDimension = function(uuid) {
  d3.select('#' + uuid)
        .remove();
}

wps.loadRegrid = function() {
  var gaussian = `
      <input name="gaussian-lats" id="gaussian-lats" type="number" placeholder="Lats" />
  `;
  var uniform = `
      <input name="uniform-lons" id="uniform-lons" type="number" placeholder="Lons" />
      <input name="uniform-lats" id="uniform-lats" type="number" placeholder="Lats" />
  `;

  d3.select('#regrid')
      .on('change', function() {
        var gridType = wps.REGRID[this.selectedIndex];

        if (gridType === 'Gaussian') {
          d3.select('#regrid-control')
              .remove();

          d3.select('#regrid-col')
              .append('div')
              .attr('id', 'regrid-control')
              .style('display', 'inline')
              .html(gaussian);
        } else if (gridType === 'Uniform') {
          d3.select('#regrid-control')
              .remove();

          d3.select('#regrid-col')
              .append('div')
              .attr('id', 'regrid-control')
              .style('display', 'inline')
              .html(uniform);
        } else {
          d3.select('#regrid-control')
              .remove();
        }
      })
      .selectAll('option')
      .data(wps.REGRID)
    .enter().append('option')
      .text(function(d) { return d; });
}

wps.validateForm = function() {
  var form = document.forms['configuration'];

  if (form.variable.value === 'None') {
    alert('Invalid variable.');

    return false;
  }

  var regrid = form.regrid.value;

  if (regrid === 'Gaussian') {
    if (form['gaussian-lats'].value === '') {
      alert('Enter the number of latitudes for the Gaussian grid.');

      return false;
    }
  } else if (regrid == 'Uniform') {
    if (form['uniform-lons'].value === '' || form['uniform-lats'].value === '') {
      alert('Enter both the number of longitudes and latitudes for the Uniform grid.');

      return false;
    }
  }

  return true;
}

wps.roiDragStart = function() {
  var bar = 20;
  var x = +this.getAttribute('x');
  var y = +this.getAttribute('y');
  var width = +this.getAttribute('width');
  var height = +this.getAttribute('height');

  wps.resizeDir[0] = (d3.event.y > (y + height - bar));
  wps.resizeDir[1] = (d3.event.x < (x + bar));
  wps.resizeDir[2] = (d3.event.y < (y + bar));
  wps.resizeDir[3] = (d3.event.x > (x + width - bar));

  var elementTrue = function(element, index, array) {
    return element;
  };

  if (wps.resizeDir.some(elementTrue)) {
    wps.resize = true; 
  } else {
    wps.move = true;
  }
}

wps.roiDragEnd = function() {
  wps.move = false;

  wps.resize = false;

  for (var i = 0; i < wps.resizeDir.length; i++) {
    wps.resizeDir[i] = false;
  }
}

wps.roiDrag = function() {
  var bbox = {
    start: wps.projection([-180, 90]),
    stop: wps.projection([180, -90]),
  };
  console.log(wps.move);
  if (wps.resize) {
    var dx = d3.event.dx;
    var dy = d3.event.dy;

    if (dx != 0) {
      if (wps.resizeDir[1]) {
        wps.data.start[0] += dx;
      }
      
      if (wps.resizeDir[3]) {
        wps.data.stop[0] += dx;
      }
    }

    if (dy != 0) {
      if (wps.resizeDir[2]) {
        wps.data.start[1] += dy;
      }

      if (wps.resizeDir[0]) {
        wps.data.stop[1] += dy;
      }
    }
  } else if (wps.move) {
    var x = +this.getAttribute('x');
    var y = +this.getAttribute('y');
    var width = +this.getAttribute('width');
    var height = +this.getAttribute('height');
    var dx = d3.event.dx;
    var dy = d3.event.dy;

    if ((dx <= -1 && x != bbox.start[0]) || (dx >= 1 && (x + width) != bbox.stop[0])) {
      wps.data.start[0] += dx;

      if (wps.data.start[0] < bbox.start[0]) wps.data.start[0] = bbox.start[0];

      wps.data.stop[0] += dx;

      if (wps.data.stop[0] > bbox.stop[0]) wps.data.stop[0] = bbox.stop[0];
    }

    if ((dy <= -1 && y != bbox.start[1]) || (dy >= 1 && (y + height) != bbox.stop[1])) {
      wps.data.start[1] += dy;

      if (wps.data.start[1] < bbox.start[1]) wps.data.start[1] = bbox.start[1];

      wps.data.stop[1] += dy;

      if (wps.data.stop[1] > bbox.stop[1]) wps.data.stop[1] = bbox.stop[1];
    }
  }

  wps.dispatch.call('updateUIROI');

  wps.dispatch.call('updateROI');
}

wps.domReady = function() {
  var dispatch = d3.dispatch('updateROI', 'updateUIROI');

  wps.dispatch = dispatch;

  wps.loadDomains(dispatch);

  wps.loadRegrid();

  var node = d3.select('#map').node();

  var rect = node.getBoundingClientRect();

  var width = rect.width;
  var height = width / 1.92;

  var svg = d3.select('svg')
      .attr('width', width)
      .attr('height', height)
      .style('border-style', 'solid')
      .style('border-width', '0.5px');

  svg.append('text')
      .attr('class', 'coords')
      .attr('x', 5)
      .attr('y', 15);

  // defined here since we use the closure on the data variable
  function create_control(dimension, postFix, projection) {
    d3.select('#' + dimension + '-' + postFix)
        .on('change', function() {
          wps.data.start = projection(wps.geoCoord('start'));

          wps.data.stop = projection(wps.geoCoord('stop'));

          dispatch.call('updateROI');
        });
  }

  // load the data, setup the projection and start drawing
  d3.json(window.location.origin + '/static/js/world.json', function(error, world) {
    if (error) throw error;

    var f = d3.format('.2f');
    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var projection = d3.geoEquirectangular();

    wps.projection = projection;
    
    create_control('lon', 'start', projection); 

    create_control('lon', 'stop', projection);

    create_control('lat', 'start', projection);

    create_control('lat', 'stop', projection);
    
    dispatch.on('updateROI', function() {
      d3.select('.roi')
          .attr('x', wps.data.start[0])
          .attr('y', wps.data.start[1])
          .attr('width', wps.data.stop[0] - wps.data.start[0])
          .attr('height', wps.data.stop[1] - wps.data.start[1]);

      d3.select('#domain_modified').attr('value', 'true'); 
    });
    
    dispatch.on('updateUIROI', function() {
      var start = projection.invert(wps.data.start);
      var stop = projection.invert(wps.data.stop);

      d3.select('#lon-start').attr('value', f(start[0].map(-180, 180, 0, 360)));
      d3.select('#lon-stop').attr('value', f(stop[0].map(-180, 180, 0, 360)));

      d3.select('#lat-start').attr('value', f(start[1]));
      d3.select('#lat-stop').attr('value', f(stop[1]));
    });

    svg.on('mousemove', function() {
      var coords = d3.mouse(this);

      var geoCoords = projection.invert(coords);

      d3.select('.coords')
          .html(f(geoCoords[0]) + ' &deg;, ' + f(geoCoords[1]) + '&deg;');
    });

    var countries = topojson.feature(world, world.objects.countries);
    var neighbors = topojson.neighbors(world.objects.countries.geometries);

    projection.fitSize([width, height], countries);

    var path = d3.geoPath(projection);
    var graticule = d3.geoGraticule();

    svg.append('path')
        .datum(graticule)
        .attr('class', 'graticule')
        .attr('d', path);

    wps.data.start = projection(wps.geoCoord('start'));

    wps.data.stop = projection(wps.geoCoord('stop'));

    svg.append('rect')
        .attr('x', wps.data.start[0])
        .attr('y', wps.data.start[1])
        .attr('width', wps.data.stop[0] - wps.data.start[0])
        .attr('height', wps.data.stop[1] - wps.data.start[1])
        .attr('class', 'roi')
        .call(d3.drag()
          .on('start', wps.roiDragStart)
          .on('end', wps.roiDragEnd)
          .on('drag', wps.roiDrag)
        );

    svg.selectAll('.country')
        .data(countries.features)
      .enter().insert('path', '.graticule')
        .attr('class', 'country')
        .attr('d', path)
        .attr('fill', function(d, i) {
          return color(d.color = d3.max(neighbors[i], function(n) {
            return countries.features[n].color;
          }) + 1 | 0);
        });
  });
}

YAHOO.util.Event.onDOMReady(wps.domReady);

</script>
